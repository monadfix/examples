{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE InstanceSigs #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE AllowAmbiguousTypes #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE NoMonomorphismRestriction #-}

module Main where

import Data.Text (Text)
import qualified Data.Text as Text
import Control.Monad.Reader
import Control.Concurrent (forkIO)

import Network.Wai.Handler.Warp (run)
import Network.HTTP.Client (newManager, defaultManagerSettings)

import Servant
import Servant.API
import Servant.Client
import Servant.Client.Core

import Mock -- magic


-- A simple API with two endpoints: one for reversing a string and one for
-- replicating it.
type Api =
         "reverse"
             :> Capture "s" Text
             :> Get '[JSON] Text
    :<|> "replicate"
             :> Capture "n" Int
             :> Capture "s" Text
             :> Get '[JSON] [Text]

-- Autogenerated client functions. To add type signatures to them, you might
-- have to use something like this:
--
-- http://hackage.haskell.org/package/servant-client-core-0.14/docs/Servant-Client-Core-Reexport.html#t:ClientLike

callReverse :<|> callReplicate = clientIn (Proxy @Api) Proxy

-- A mock server.

mockServer :: Server Api
mockServer =
    (\s -> pure (Text.reverse s))
    :<|>
    (\n s -> pure (replicate n s))

-- An example of using the client functions.

main :: IO ()
main = do
    -- We can talk to the server over the network
    putStrLn "Network calls:"
    forkIO $ run 25000 $ serve (Proxy @Api) mockServer
    manager <- newManager defaultManagerSettings
    let env  = mkClientEnv manager (BaseUrl Http "0.0.0.0" 25000 "")
        call = flip runClientM env
    print =<< call (callReverse "hello")
    print =<< call (callReplicate 3 "test")

    -- Or we can use the mock server directly!
    putStrLn "No-network calls:"
    flip runReaderT (serve (Proxy @Api) mockServer) $ do
        lift . print =<< callReverse "hello"
        lift . print =<< callReplicate 3 "test"
