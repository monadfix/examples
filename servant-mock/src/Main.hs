{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE InstanceSigs #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE AllowAmbiguousTypes #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE NoMonomorphismRestriction #-}

module Main where

import Data.Text (Text)
import qualified Data.Text as Text
import Control.Monad.Reader
import Control.Concurrent (forkIO)

import Network.Wai.Handler.Warp (run)
import Network.HTTP.Client (newManager, defaultManagerSettings)

import Servant
import Servant.API
import Servant.Client
import Servant.Client.Core

import Mock -- magic


-- A simple API with two endpoints: one for reversing a string and one for
-- replicating it.
type Api =
         "reverse"
             :> Capture "s" Text
             :> Get '[JSON] Text
    :<|> "replicate"
             :> Capture "n" Int
             :> Capture "s" Text
             :> Get '[JSON] [Text]

-- Autogenerated client functions.
callReverse :<|> callReplicate = clientIn (Proxy @Api) Proxy

-- A mock server.
mockServer :: Server Api
mockServer =
    (\s -> pure (Text.reverse s))
    :<|>
    (\n s -> pure (replicate n s))

-- A function that can either use real networking, or the mock server.
action :: (MonadIO m, RunClient m) => m ()
action = do
    liftIO . print =<< callReverse "hello"
    liftIO . print =<< callReplicate 3 "test"
    liftIO (putStrLn "")

main :: IO ()
main = do
    -- We can run 'action' and talk to a server over the network
    putStrLn "Network calls:"
    forkIO $ run 25000 $ serve (Proxy @Api) mockServer
    manager <- newManager defaultManagerSettings
    let env = mkClientEnv manager (BaseUrl Http "0.0.0.0" 25000 "")
    runClientM action env

    -- Or we run 'action' against the mock server directly!
    putStrLn "No-network calls:"
    runReaderT action (serve (Proxy @Api) mockServer)
